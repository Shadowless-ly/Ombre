"""
# 相关概念

## 进程(Process)

在面向进程设计的操作系统中(linux2.4及以前)，进程是程序运行的基本单位；而在面向线程设计的操作系统中(linux2.6以及之后)，进程只是线程的容器，操作系统调度的单位是线程。
进程只是用于隔离不同的进程，不同进程间资源不同享，进程内资源可以共享。
进程的基本模型和基本行为是由操作系统定义的，编程语言只能遵照实现。

### 子进程，父进程，主进程

可以从一个进程启动另一个进程，新启动的进程称为子进程，启动子进程的进程称为父进程，原始最先执行的进程称为主进程。

## 线程(Thread)

线程是现在操作系统调度任务的基本单位，是进程的组成部分，同一进程下的多个不同线程可以共享进程的计算机资源，各个进程之间的资源一般不共享。
操作系统使用线程模型，是为了提供将任务分解为多个子任务并发或并行运行的解决方案，提高程序的执行效率。

# 子线程，父线程，主线程

可以从一个线程启动别的线程，被启动的为子线程，原来的是父线程，原始最先执行的为主线程。

# 例程(Routine)

语言级别内定义可以被调动的代码段，为了完成某个特定功能而封装在一起的一系列指令。一般编程语言都用称为函数或方法的代发结构来体现。

## 子例程(Subroutine)

例程中定义的例程。注意例程可以嵌套定义，而且例程也本就是代码拆分设计的子程序。

# 并发(Concurrent)

并发描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务(以利用有限的计算机资源十多个任务可以被实时或者近实时执行为目的)

# 并行(parallel)

并行是指程序的执行状态。指多个任务同时在多个CPU上执行(以利用富余的计算机资源加速完成多个任务为目的)

# 协程(Co-routine)

Coroutine也就是corporate routine，翻译为协同的例程。此概念和进程与线程类似，也叫做轻量级进程。
* 协程是非抢占式的多任务子例程的概括，可以允许多个入口点在例程中确认的位置来控制程序的暂停和恢复执行 *
多个入口点可以在一个协程中多次使用如yield的关键字，每个yield的位置，都是程序员可以使之让出执行权、暂停、恢复、传递信号、注入执行结果等操作。
函数在线程中执行，自然协程是在线程中执行，多个协程共享该线程拥有的资源，由于协程就是函数或方法，在线程运行初始化时，所以，和函数一样，协程的数据结构存放在线程的栈内存中。
* 所以协程的切换，实际上就是函数的调用，是在线程的栈内存中完成的 *
进程和线程的切换，要保存很复杂的状态，内存占用也大，操作系统调度复杂，所以协程的切换开销很小。
协程也是可以跨线程调度的，如同一个函数可以放到另一个线程去执行一样。


1。 相同点：
    二者都是可以看做一种执行流，该执行流可以挂起，并且将来又可以在你挂起的地方恢复。
    当我们挂起一个执行流时我们需要保存一些东西：
        a. 栈，如果你不保存栈，那么局部变量无法恢复，函数调用链也无法恢复
        b. 寄存器状态，如EIP如果没有则恢复时无法得知执行哪一条指令，
        如ESP，EBP，如果不保存，即便是拥有完整的栈也不知道如何使用。
    这两个就是所谓的上下文，continuation，在执行流切换时，这两个东西必须保存，就如同内核调用进程一样。
2。 不同点：
    a. 执行流的调度者不同，进程是内核调度，而协程是在用户态调度。也就是说进程的上下文是在内核态保存回复的，而协程是在用户态保存恢复的，代价更低。
    b. 进程会被抢占，而协程不会，使用yield原语，一个进程调用yield则会让出CPU，其他进程就有机会执行。
    c. 对于内存的占用不同，实际上协程只需要4K的栈就够了，而内存占用的内存要大很多。
    d. 从操作系统来讲，多协程是单线程，单进程的。

异步框架:Tornado，Twisted，Gevent
而Flask，Django等传统WEB框架为非异步框架。
Python3增加了async库和async/await语法，可以简洁高效的使用Python异步。
"""
